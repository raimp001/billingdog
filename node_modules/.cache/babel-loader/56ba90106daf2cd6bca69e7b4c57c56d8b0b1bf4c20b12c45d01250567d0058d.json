{"ast":null,"code":"// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\n\n/* eslint-disable */\n//prettier-ignore\nconst createKeccakHash = require('keccak/js');\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nfunction zeros(bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n}\nfunction bitLengthFromBigInt(num) {\n  return num.toString(2).length;\n}\nfunction bufferBEFromBigInt(num, length) {\n  let hex = num.toString(16);\n  // Ensure the hex string length is even\n  if (hex.length % 2 !== 0) hex = '0' + hex;\n  // Convert hex string to a byte array\n  const byteArray = hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  // Ensure the byte array is of the specified length\n  while (byteArray.length < length) {\n    byteArray.unshift(0); // Prepend with zeroes if shorter than required length\n  }\n  return Buffer.from(byteArray);\n}\nfunction twosFromBigInt(value, width) {\n  const isNegative = value < 0n;\n  let result;\n  if (isNegative) {\n    // Prepare a mask for the specified width to perform NOT operation\n    const mask = (1n << BigInt(width)) - 1n;\n    // Invert bits (using NOT) and add one\n    result = (~value & mask) + 1n;\n  } else {\n    result = value;\n  }\n  // Ensure the result fits in the specified width\n  result &= (1n << BigInt(width)) - 1n;\n  return result;\n}\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nfunction setLength(msg, length, right) {\n  const buf = zeros(length);\n  msg = toBuffer(msg);\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n    return msg.slice(-length);\n  }\n}\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nfunction setLengthRight(msg, length) {\n  return setLength(msg, length, true);\n}\n\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BIgInt` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nfunction toBuffer(v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (typeof v === 'bigint') {\n      v = bufferBEFromBigInt(v);\n    } else if (v.toArray) {\n      // TODO: bigint should be handled above, may remove this duplicate\n      // converts a BigInt to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n  return v;\n}\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nfunction bufferToHex(buf) {\n  buf = toBuffer(buf);\n  return '0x' + buf.toString('hex');\n}\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nfunction keccak(a, bits) {\n  a = toBuffer(a);\n  if (!bits) bits = 256;\n  return createKeccakHash('keccak' + bits).update(a).digest();\n}\nfunction padToEven(str) {\n  return str.length % 2 ? '0' + str : str;\n}\nfunction isHexString(str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/);\n}\nfunction stripHexPrefix(str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2);\n  }\n  return str;\n}\nmodule.exports = {\n  zeros,\n  setLength,\n  setLengthRight,\n  isHexString,\n  stripHexPrefix,\n  toBuffer,\n  bufferToHex,\n  keccak,\n  bitLengthFromBigInt,\n  bufferBEFromBigInt,\n  twosFromBigInt\n};","map":{"version":3,"names":["createKeccakHash","require","zeros","bytes","Buffer","allocUnsafe","fill","bitLengthFromBigInt","num","toString","length","bufferBEFromBigInt","hex","byteArray","match","map","byte","parseInt","unshift","from","twosFromBigInt","value","width","isNegative","result","mask","BigInt","setLength","msg","right","buf","toBuffer","copy","slice","setLengthRight","v","isBuffer","Array","isArray","isHexString","padToEven","stripHexPrefix","intToBuffer","undefined","toArray","Error","bufferToHex","keccak","a","bits","update","digest","str","startsWith","module","exports"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js"],"sourcesContent":["// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\n\n/* eslint-disable */\n//prettier-ignore\nconst createKeccakHash = require('keccak/js')\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nfunction zeros (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0)\n}\n\nfunction bitLengthFromBigInt (num) {\n  return num.toString(2).length\n}\n\nfunction bufferBEFromBigInt(num, length) {\n  let hex = num.toString(16);\n  // Ensure the hex string length is even\n  if (hex.length % 2 !== 0) hex = '0' + hex;\n  // Convert hex string to a byte array\n  const byteArray = hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  // Ensure the byte array is of the specified length\n  while (byteArray.length < length) {\n    byteArray.unshift(0); // Prepend with zeroes if shorter than required length\n  }\n\n  return Buffer.from(byteArray);\n}\n\nfunction twosFromBigInt(value, width) {\n  const isNegative = value < 0n;\n  let result;\n  if (isNegative) {\n    // Prepare a mask for the specified width to perform NOT operation\n    const mask = (1n << BigInt(width)) - 1n;\n    // Invert bits (using NOT) and add one\n    result = (~value & mask) + 1n;\n  } else {\n    result = value;\n  }\n  // Ensure the result fits in the specified width\n  result &= (1n << BigInt(width)) - 1n;\n\n  return result;\n}\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nfunction setLength (msg, length, right) {\n  const buf = zeros(length)\n  msg = toBuffer(msg)\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf)\n      return buf\n    }\n    return msg.slice(0, length)\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length)\n      return buf\n    }\n    return msg.slice(-length)\n  }\n}\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nfunction setLengthRight (msg, length) {\n  return setLength(msg, length, true)\n}\n\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BIgInt` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nfunction toBuffer (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v)\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')\n      } else {\n        v = Buffer.from(v)\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v)\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0)\n    } else if (typeof v === 'bigint') {\n      v = bufferBEFromBigInt(v)\n    } else if (v.toArray) {\n      // TODO: bigint should be handled above, may remove this duplicate\n      // converts a BigInt to a Buffer\n      v = Buffer.from(v.toArray())\n    } else {\n      throw new Error('invalid type')\n    }\n  }\n  return v\n}\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nfunction bufferToHex (buf) {\n  buf = toBuffer(buf)\n  return '0x' + buf.toString('hex')\n}\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nfunction keccak (a, bits) {\n  a = toBuffer(a)\n  if (!bits) bits = 256\n\n  return createKeccakHash('keccak' + bits).update(a).digest()\n}\n\nfunction padToEven (str) {\n  return str.length % 2 ? '0' + str : str\n}\n\nfunction isHexString (str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)\n}\n\nfunction stripHexPrefix (str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2)\n  }\n  return str\n}\n\nmodule.exports = {\n  zeros,\n  setLength,\n  setLengthRight,\n  isHexString,\n  stripHexPrefix,\n  toBuffer,\n  bufferToHex,\n  keccak,\n  bitLengthFromBigInt,\n  bufferBEFromBigInt,\n  twosFromBigInt\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}