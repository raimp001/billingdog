{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SCWSigner = void 0;\nconst SCWKeyManager_1 = require(\"./SCWKeyManager\");\nconst SCWStateManager_1 = require(\"./SCWStateManager\");\nconst error_1 = require(\"../../core/error\");\nconst util_1 = require(\"../../core/type/util\");\nconst cipher_1 = require(\"../../util/cipher\");\nclass SCWSigner {\n  constructor(params) {\n    this.metadata = params.metadata;\n    this.communicator = params.communicator;\n    this.keyManager = new SCWKeyManager_1.SCWKeyManager();\n    this.stateManager = new SCWStateManager_1.SCWStateManager({\n      appChainIds: this.metadata.appChainIds,\n      updateListener: params.updateListener\n    });\n    this.handshake = this.handshake.bind(this);\n    this.request = this.request.bind(this);\n    this.createRequestMessage = this.createRequestMessage.bind(this);\n    this.decryptResponseMessage = this.decryptResponseMessage.bind(this);\n  }\n  async handshake() {\n    const handshakeMessage = await this.createRequestMessage({\n      handshake: {\n        method: 'eth_requestAccounts',\n        params: this.metadata\n      }\n    });\n    const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);\n    // store peer's public key\n    if ('failure' in response.content) throw response.content.failure;\n    const peerPublicKey = await (0, cipher_1.importKeyFromHexString)('public', response.sender);\n    await this.keyManager.setPeerPublicKey(peerPublicKey);\n    const decrypted = await this.decryptResponseMessage(response);\n    this.updateInternalState({\n      method: 'eth_requestAccounts'\n    }, decrypted);\n    const result = decrypted.result;\n    if ('error' in result) throw result.error;\n    return this.stateManager.accounts;\n  }\n  async request(request) {\n    const localResult = this.tryLocalHandling(request);\n    if (localResult !== undefined) {\n      if (localResult instanceof Error) throw localResult;\n      return localResult;\n    }\n    // Open the popup before constructing the request message.\n    // This is to ensure that the popup is not blocked by some browsers (i.e. Safari)\n    await this.communicator.waitForPopupLoaded();\n    const response = await this.sendEncryptedRequest(request);\n    const decrypted = await this.decryptResponseMessage(response);\n    this.updateInternalState(request, decrypted);\n    const result = decrypted.result;\n    if ('error' in result) throw result.error;\n    return result.value;\n  }\n  async disconnect() {\n    this.stateManager.clear();\n    await this.keyManager.clear();\n  }\n  tryLocalHandling(request) {\n    var _a;\n    switch (request.method) {\n      case 'wallet_switchEthereumChain':\n        {\n          const params = request.params;\n          if (!params || !((_a = params[0]) === null || _a === void 0 ? void 0 : _a.chainId)) {\n            throw error_1.standardErrors.rpc.invalidParams();\n          }\n          const chainId = (0, util_1.ensureIntNumber)(params[0].chainId);\n          const switched = this.stateManager.switchChain(chainId);\n          // \"return null if the request was successful\"\n          // https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n          return switched ? null : undefined;\n        }\n      case 'wallet_getCapabilities':\n        {\n          const walletCapabilities = this.stateManager.walletCapabilities;\n          if (!walletCapabilities) {\n            // This should never be the case for scw connections as capabilities are set during handshake\n            throw error_1.standardErrors.provider.unauthorized('No wallet capabilities found, please disconnect and reconnect');\n          }\n          return walletCapabilities;\n        }\n      default:\n        return undefined;\n    }\n  }\n  async sendEncryptedRequest(request) {\n    const sharedSecret = await this.keyManager.getSharedSecret();\n    if (!sharedSecret) {\n      throw error_1.standardErrors.provider.unauthorized('No valid session found, try requestAccounts before other methods');\n    }\n    const encrypted = await (0, cipher_1.encryptContent)({\n      action: request,\n      chainId: this.stateManager.activeChain.id\n    }, sharedSecret);\n    const message = await this.createRequestMessage({\n      encrypted\n    });\n    return this.communicator.postRequestAndWaitForResponse(message);\n  }\n  async createRequestMessage(content) {\n    const publicKey = await (0, cipher_1.exportKeyToHexString)('public', await this.keyManager.getOwnPublicKey());\n    return {\n      id: crypto.randomUUID(),\n      sender: publicKey,\n      content,\n      timestamp: new Date()\n    };\n  }\n  async decryptResponseMessage(message) {\n    const content = message.content;\n    // throw protocol level error\n    if ('failure' in content) {\n      throw content.failure;\n    }\n    const sharedSecret = await this.keyManager.getSharedSecret();\n    if (!sharedSecret) {\n      throw error_1.standardErrors.provider.unauthorized('Invalid session');\n    }\n    return (0, cipher_1.decryptContent)(content.encrypted, sharedSecret);\n  }\n  updateInternalState(request, response) {\n    var _a, _b;\n    const availableChains = (_a = response.data) === null || _a === void 0 ? void 0 : _a.chains;\n    if (availableChains) {\n      this.stateManager.updateAvailableChains(availableChains);\n    }\n    const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;\n    if (walletCapabilities) {\n      this.stateManager.updateWalletCapabilities(walletCapabilities);\n    }\n    const result = response.result;\n    if ('error' in result) return;\n    switch (request.method) {\n      case 'eth_requestAccounts':\n        {\n          const accounts = result.value;\n          this.stateManager.updateAccounts(accounts);\n          break;\n        }\n      case 'wallet_switchEthereumChain':\n        {\n          // \"return null if the request was successful\"\n          // https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n          if (result.value !== null) return;\n          const params = request.params;\n          const chainId = (0, util_1.ensureIntNumber)(params[0].chainId);\n          this.stateManager.switchChain(chainId);\n          break;\n        }\n      default:\n        break;\n    }\n  }\n}\nexports.SCWSigner = SCWSigner;","map":{"version":3,"names":["Object","defineProperty","exports","value","SCWSigner","SCWKeyManager_1","require","SCWStateManager_1","error_1","util_1","cipher_1","constructor","params","metadata","communicator","keyManager","SCWKeyManager","stateManager","SCWStateManager","appChainIds","updateListener","handshake","bind","request","createRequestMessage","decryptResponseMessage","handshakeMessage","method","response","postRequestAndWaitForResponse","content","failure","peerPublicKey","importKeyFromHexString","sender","setPeerPublicKey","decrypted","updateInternalState","result","error","accounts","localResult","tryLocalHandling","undefined","Error","waitForPopupLoaded","sendEncryptedRequest","disconnect","clear","_a","chainId","standardErrors","rpc","invalidParams","ensureIntNumber","switched","switchChain","walletCapabilities","provider","unauthorized","sharedSecret","getSharedSecret","encrypted","encryptContent","action","activeChain","id","message","publicKey","exportKeyToHexString","getOwnPublicKey","crypto","randomUUID","timestamp","Date","decryptContent","_b","availableChains","data","chains","updateAvailableChains","capabilities","updateWalletCapabilities","updateAccounts"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SCWSigner = void 0;\nconst SCWKeyManager_1 = require(\"./SCWKeyManager\");\nconst SCWStateManager_1 = require(\"./SCWStateManager\");\nconst error_1 = require(\"../../core/error\");\nconst util_1 = require(\"../../core/type/util\");\nconst cipher_1 = require(\"../../util/cipher\");\nclass SCWSigner {\n    constructor(params) {\n        this.metadata = params.metadata;\n        this.communicator = params.communicator;\n        this.keyManager = new SCWKeyManager_1.SCWKeyManager();\n        this.stateManager = new SCWStateManager_1.SCWStateManager({\n            appChainIds: this.metadata.appChainIds,\n            updateListener: params.updateListener,\n        });\n        this.handshake = this.handshake.bind(this);\n        this.request = this.request.bind(this);\n        this.createRequestMessage = this.createRequestMessage.bind(this);\n        this.decryptResponseMessage = this.decryptResponseMessage.bind(this);\n    }\n    async handshake() {\n        const handshakeMessage = await this.createRequestMessage({\n            handshake: {\n                method: 'eth_requestAccounts',\n                params: this.metadata,\n            },\n        });\n        const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);\n        // store peer's public key\n        if ('failure' in response.content)\n            throw response.content.failure;\n        const peerPublicKey = await (0, cipher_1.importKeyFromHexString)('public', response.sender);\n        await this.keyManager.setPeerPublicKey(peerPublicKey);\n        const decrypted = await this.decryptResponseMessage(response);\n        this.updateInternalState({ method: 'eth_requestAccounts' }, decrypted);\n        const result = decrypted.result;\n        if ('error' in result)\n            throw result.error;\n        return this.stateManager.accounts;\n    }\n    async request(request) {\n        const localResult = this.tryLocalHandling(request);\n        if (localResult !== undefined) {\n            if (localResult instanceof Error)\n                throw localResult;\n            return localResult;\n        }\n        // Open the popup before constructing the request message.\n        // This is to ensure that the popup is not blocked by some browsers (i.e. Safari)\n        await this.communicator.waitForPopupLoaded();\n        const response = await this.sendEncryptedRequest(request);\n        const decrypted = await this.decryptResponseMessage(response);\n        this.updateInternalState(request, decrypted);\n        const result = decrypted.result;\n        if ('error' in result)\n            throw result.error;\n        return result.value;\n    }\n    async disconnect() {\n        this.stateManager.clear();\n        await this.keyManager.clear();\n    }\n    tryLocalHandling(request) {\n        var _a;\n        switch (request.method) {\n            case 'wallet_switchEthereumChain': {\n                const params = request.params;\n                if (!params || !((_a = params[0]) === null || _a === void 0 ? void 0 : _a.chainId)) {\n                    throw error_1.standardErrors.rpc.invalidParams();\n                }\n                const chainId = (0, util_1.ensureIntNumber)(params[0].chainId);\n                const switched = this.stateManager.switchChain(chainId);\n                // \"return null if the request was successful\"\n                // https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n                return switched ? null : undefined;\n            }\n            case 'wallet_getCapabilities': {\n                const walletCapabilities = this.stateManager.walletCapabilities;\n                if (!walletCapabilities) {\n                    // This should never be the case for scw connections as capabilities are set during handshake\n                    throw error_1.standardErrors.provider.unauthorized('No wallet capabilities found, please disconnect and reconnect');\n                }\n                return walletCapabilities;\n            }\n            default:\n                return undefined;\n        }\n    }\n    async sendEncryptedRequest(request) {\n        const sharedSecret = await this.keyManager.getSharedSecret();\n        if (!sharedSecret) {\n            throw error_1.standardErrors.provider.unauthorized('No valid session found, try requestAccounts before other methods');\n        }\n        const encrypted = await (0, cipher_1.encryptContent)({\n            action: request,\n            chainId: this.stateManager.activeChain.id,\n        }, sharedSecret);\n        const message = await this.createRequestMessage({ encrypted });\n        return this.communicator.postRequestAndWaitForResponse(message);\n    }\n    async createRequestMessage(content) {\n        const publicKey = await (0, cipher_1.exportKeyToHexString)('public', await this.keyManager.getOwnPublicKey());\n        return {\n            id: crypto.randomUUID(),\n            sender: publicKey,\n            content,\n            timestamp: new Date(),\n        };\n    }\n    async decryptResponseMessage(message) {\n        const content = message.content;\n        // throw protocol level error\n        if ('failure' in content) {\n            throw content.failure;\n        }\n        const sharedSecret = await this.keyManager.getSharedSecret();\n        if (!sharedSecret) {\n            throw error_1.standardErrors.provider.unauthorized('Invalid session');\n        }\n        return (0, cipher_1.decryptContent)(content.encrypted, sharedSecret);\n    }\n    updateInternalState(request, response) {\n        var _a, _b;\n        const availableChains = (_a = response.data) === null || _a === void 0 ? void 0 : _a.chains;\n        if (availableChains) {\n            this.stateManager.updateAvailableChains(availableChains);\n        }\n        const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;\n        if (walletCapabilities) {\n            this.stateManager.updateWalletCapabilities(walletCapabilities);\n        }\n        const result = response.result;\n        if ('error' in result)\n            return;\n        switch (request.method) {\n            case 'eth_requestAccounts': {\n                const accounts = result.value;\n                this.stateManager.updateAccounts(accounts);\n                break;\n            }\n            case 'wallet_switchEthereumChain': {\n                // \"return null if the request was successful\"\n                // https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n                if (result.value !== null)\n                    return;\n                const params = request.params;\n                const chainId = (0, util_1.ensureIntNumber)(params[0].chainId);\n                this.stateManager.switchChain(chainId);\n                break;\n            }\n            default:\n                break;\n        }\n    }\n}\nexports.SCWSigner = SCWSigner;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}