{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptContent = exports.encryptContent = exports.importKeyFromHexString = exports.exportKeyToHexString = exports.decrypt = exports.encrypt = exports.deriveSharedSecret = exports.generateKeyPair = void 0;\nconst util_1 = require(\"../core/type/util\");\nasync function generateKeyPair() {\n  return crypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, true, ['deriveKey']);\n}\nexports.generateKeyPair = generateKeyPair;\nasync function deriveSharedSecret(ownPrivateKey, peerPublicKey) {\n  return crypto.subtle.deriveKey({\n    name: 'ECDH',\n    public: peerPublicKey\n  }, ownPrivateKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, false, ['encrypt', 'decrypt']);\n}\nexports.deriveSharedSecret = deriveSharedSecret;\nasync function encrypt(sharedSecret, plainText) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const cipherText = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, sharedSecret, new TextEncoder().encode(plainText));\n  return {\n    iv,\n    cipherText\n  };\n}\nexports.encrypt = encrypt;\nasync function decrypt(sharedSecret, _ref) {\n  let {\n    iv,\n    cipherText\n  } = _ref;\n  const plainText = await crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, sharedSecret, cipherText);\n  return new TextDecoder().decode(plainText);\n}\nexports.decrypt = decrypt;\nfunction getFormat(keyType) {\n  switch (keyType) {\n    case 'public':\n      return 'spki';\n    case 'private':\n      return 'pkcs8';\n  }\n}\nasync function exportKeyToHexString(type, key) {\n  const format = getFormat(type);\n  const exported = await crypto.subtle.exportKey(format, key);\n  return (0, util_1.uint8ArrayToHex)(new Uint8Array(exported));\n}\nexports.exportKeyToHexString = exportKeyToHexString;\nasync function importKeyFromHexString(type, hexString) {\n  const format = getFormat(type);\n  const arrayBuffer = (0, util_1.hexStringToUint8Array)(hexString).buffer;\n  return await crypto.subtle.importKey(format, arrayBuffer, {\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, true, type === 'private' ? ['deriveKey'] : []);\n}\nexports.importKeyFromHexString = importKeyFromHexString;\nasync function encryptContent(content, sharedSecret) {\n  const serialized = JSON.stringify(content, (_, value) => {\n    if (!(value instanceof Error)) return value;\n    const error = value;\n    return Object.assign(Object.assign({}, error.code ? {\n      code: error.code\n    } : {}), {\n      message: error.message\n    });\n  });\n  return encrypt(sharedSecret, serialized);\n}\nexports.encryptContent = encryptContent;\nasync function decryptContent(encryptedData, sharedSecret) {\n  return JSON.parse(await decrypt(sharedSecret, encryptedData));\n}\nexports.decryptContent = decryptContent;","map":{"version":3,"names":["Object","defineProperty","exports","value","decryptContent","encryptContent","importKeyFromHexString","exportKeyToHexString","decrypt","encrypt","deriveSharedSecret","generateKeyPair","util_1","require","crypto","subtle","generateKey","name","namedCurve","ownPrivateKey","peerPublicKey","deriveKey","public","length","sharedSecret","plainText","iv","getRandomValues","Uint8Array","cipherText","TextEncoder","encode","_ref","TextDecoder","decode","getFormat","keyType","type","key","format","exported","exportKey","uint8ArrayToHex","hexString","arrayBuffer","hexStringToUint8Array","buffer","importKey","content","serialized","JSON","stringify","_","Error","error","assign","code","message","encryptedData","parse"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/util/cipher.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptContent = exports.encryptContent = exports.importKeyFromHexString = exports.exportKeyToHexString = exports.decrypt = exports.encrypt = exports.deriveSharedSecret = exports.generateKeyPair = void 0;\nconst util_1 = require(\"../core/type/util\");\nasync function generateKeyPair() {\n    return crypto.subtle.generateKey({\n        name: 'ECDH',\n        namedCurve: 'P-256',\n    }, true, ['deriveKey']);\n}\nexports.generateKeyPair = generateKeyPair;\nasync function deriveSharedSecret(ownPrivateKey, peerPublicKey) {\n    return crypto.subtle.deriveKey({\n        name: 'ECDH',\n        public: peerPublicKey,\n    }, ownPrivateKey, {\n        name: 'AES-GCM',\n        length: 256,\n    }, false, ['encrypt', 'decrypt']);\n}\nexports.deriveSharedSecret = deriveSharedSecret;\nasync function encrypt(sharedSecret, plainText) {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const cipherText = await crypto.subtle.encrypt({\n        name: 'AES-GCM',\n        iv,\n    }, sharedSecret, new TextEncoder().encode(plainText));\n    return { iv, cipherText };\n}\nexports.encrypt = encrypt;\nasync function decrypt(sharedSecret, { iv, cipherText }) {\n    const plainText = await crypto.subtle.decrypt({\n        name: 'AES-GCM',\n        iv,\n    }, sharedSecret, cipherText);\n    return new TextDecoder().decode(plainText);\n}\nexports.decrypt = decrypt;\nfunction getFormat(keyType) {\n    switch (keyType) {\n        case 'public':\n            return 'spki';\n        case 'private':\n            return 'pkcs8';\n    }\n}\nasync function exportKeyToHexString(type, key) {\n    const format = getFormat(type);\n    const exported = await crypto.subtle.exportKey(format, key);\n    return (0, util_1.uint8ArrayToHex)(new Uint8Array(exported));\n}\nexports.exportKeyToHexString = exportKeyToHexString;\nasync function importKeyFromHexString(type, hexString) {\n    const format = getFormat(type);\n    const arrayBuffer = (0, util_1.hexStringToUint8Array)(hexString).buffer;\n    return await crypto.subtle.importKey(format, arrayBuffer, {\n        name: 'ECDH',\n        namedCurve: 'P-256',\n    }, true, type === 'private' ? ['deriveKey'] : []);\n}\nexports.importKeyFromHexString = importKeyFromHexString;\nasync function encryptContent(content, sharedSecret) {\n    const serialized = JSON.stringify(content, (_, value) => {\n        if (!(value instanceof Error))\n            return value;\n        const error = value;\n        return Object.assign(Object.assign({}, (error.code ? { code: error.code } : {})), { message: error.message });\n    });\n    return encrypt(sharedSecret, serialized);\n}\nexports.encryptContent = encryptContent;\nasync function decryptContent(encryptedData, sharedSecret) {\n    return JSON.parse(await decrypt(sharedSecret, encryptedData));\n}\nexports.decryptContent = decryptContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}