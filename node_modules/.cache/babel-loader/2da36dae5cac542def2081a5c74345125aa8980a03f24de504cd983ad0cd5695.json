{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\nconst constants_1 = require(\"../constants\");\nconst WalletLinkCipher_1 = require(\"./WalletLinkCipher\");\nconst WalletLinkHTTP_1 = require(\"./WalletLinkHTTP\");\nconst WalletLinkWebSocket_1 = require(\"./WalletLinkWebSocket\");\nconst type_1 = require(\"../../../../core/type\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param session Session\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param listener WalletLinkConnectionUpdateListener\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(_ref) {\n    let {\n      session,\n      linkAPIUrl,\n      listener,\n      WebSocketClass = WebSocket\n    } = _ref;\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, type_1.IntNumber)(1);\n    /**\n     * true if connected and authenticated, else false\n     * runs listener when connected status changes\n     */\n    this._connected = false;\n    /**\n     * true if linked (a guest has joined before)\n     * runs listener when linked status changes\n     */\n    this._linked = false;\n    this.shouldFetchUnseenEventsOnConnect = false;\n    this.requestResolutions = new Map();\n    this.handleSessionMetadataUpdated = metadata => {\n      if (!metadata) return;\n      // Map of metadata key to handler function\n      const handlers = new Map([['__destroyed', this.handleDestroyed], ['EthereumAddress', this.handleAccountUpdated], ['WalletUsername', this.handleWalletUsernameUpdated], ['AppVersion', this.handleAppVersionUpdated], ['ChainId', v => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl)]]);\n      // call handler for each metadata key if value is defined\n      handlers.forEach((handler, key) => {\n        const value = metadata[key];\n        if (value === undefined) return;\n        handler(value);\n      });\n    };\n    this.handleDestroyed = __destroyed => {\n      var _a;\n      if (__destroyed !== '1') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n    };\n    this.handleAccountUpdated = async encryptedEthereumAddress => {\n      var _a;\n      {\n        const address = await this.cipher.decrypt(encryptedEthereumAddress);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n      }\n    };\n    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n      var _a;\n      {\n        const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n      }\n    };\n    this.handleWalletUsernameUpdated = async walletUsername => {\n      this.handleMetadataUpdated(constants_1.WALLET_USER_NAME_KEY, walletUsername);\n    };\n    this.handleAppVersionUpdated = async appVersion => {\n      this.handleMetadataUpdated(constants_1.APP_VERSION_KEY, appVersion);\n    };\n    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n      var _a;\n      {\n        const chainId = await this.cipher.decrypt(encryptedChainId);\n        const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n      }\n    };\n    this.session = session;\n    this.cipher = new WalletLinkCipher_1.WalletLinkCipher(session.secret);\n    this.listener = listener;\n    const ws = new WalletLinkWebSocket_1.WalletLinkWebSocket(\"\".concat(linkAPIUrl, \"/rpc\"), WebSocketClass);\n    ws.setConnectionStateListener(async state => {\n      // attempt to reconnect every 5 seconds when disconnected\n      let connected = false;\n      switch (state) {\n        case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:\n          // if DISCONNECTED and not destroyed\n          if (!this.destroyed) {\n            const connect = async () => {\n              // wait 5 seconds\n              await new Promise(resolve => setTimeout(resolve, 5000));\n              // check whether it's destroyed again\n              if (!this.destroyed) {\n                // reconnect\n                ws.connect().catch(() => {\n                  connect();\n                });\n              }\n            };\n            connect();\n          }\n          break;\n        case WalletLinkWebSocket_1.ConnectionState.CONNECTED:\n          // perform authentication upon connection\n          try {\n            // if CONNECTED, authenticate, and then check link status\n            await this.authenticate();\n            this.sendIsLinked();\n            this.sendGetSessionConfig();\n            connected = true;\n          } catch (_a) {\n            /* empty */\n          }\n          // send heartbeat every n seconds while connected\n          // if CONNECTED, start the heartbeat timer\n          // first timer event updates lastHeartbeat timestamp\n          // subsequent calls send heartbeat message\n          this.updateLastHeartbeat();\n          setInterval(() => {\n            this.heartbeat();\n          }, HEARTBEAT_INTERVAL);\n          // check for unseen events\n          if (this.shouldFetchUnseenEventsOnConnect) {\n            this.fetchUnseenEventsAPI();\n          }\n          break;\n        case WalletLinkWebSocket_1.ConnectionState.CONNECTING:\n          break;\n      }\n      // distinctUntilChanged\n      if (this.connected !== connected) {\n        this.connected = connected;\n      }\n    });\n    ws.setIncomingDataListener(m => {\n      var _a;\n      switch (m.type) {\n        // handle server's heartbeat responses\n        case 'Heartbeat':\n          this.updateLastHeartbeat();\n          return;\n        // handle link status updates\n        case 'IsLinkedOK':\n        case 'Linked':\n          {\n            const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n            this.linked = linked || m.onlineGuests > 0;\n            break;\n          }\n        // handle session config updates\n        case 'GetSessionConfigOK':\n        case 'SessionConfigUpdated':\n          {\n            this.handleSessionMetadataUpdated(m.metadata);\n            break;\n          }\n        case 'Event':\n          {\n            this.handleIncomingEvent(m);\n            break;\n          }\n      }\n      // resolve request promises\n      if (m.id !== undefined) {\n        (_a = this.requestResolutions.get(m.id)) === null || _a === void 0 ? void 0 : _a(m);\n      }\n    });\n    this.ws = ws;\n    this.http = new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    if (this.destroyed) {\n      throw new Error('instance is destroyed');\n    }\n    this.ws.connect();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  destroy() {\n    this.destroyed = true;\n    this.ws.disconnect();\n    this.listener = undefined;\n  }\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  get connected() {\n    return this._connected;\n  }\n  set connected(connected) {\n    var _a;\n    this._connected = connected;\n    if (connected) (_a = this.onceConnected) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  setOnceConnected(callback) {\n    return new Promise(resolve => {\n      if (this.connected) {\n        callback().then(resolve);\n      } else {\n        this.onceConnected = () => {\n          callback().then(resolve);\n          this.onceConnected = undefined;\n        };\n      }\n    });\n  }\n  get linked() {\n    return this._linked;\n  }\n  set linked(linked) {\n    var _a, _b;\n    this._linked = linked;\n    if (linked) (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n  }\n  setOnceLinked(callback) {\n    return new Promise(resolve => {\n      if (this.linked) {\n        callback().then(resolve);\n      } else {\n        this.onceLinked = () => {\n          callback().then(resolve);\n          this.onceLinked = undefined;\n        };\n      }\n    });\n  }\n  async handleIncomingEvent(m) {\n    var _a;\n    if (m.type !== 'Event' || m.event !== 'Web3Response') {\n      return;\n    }\n    {\n      const decryptedData = await this.cipher.decrypt(m.data);\n      const message = JSON.parse(decryptedData);\n      if (message.type !== 'WEB3_RESPONSE') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message);\n    }\n  }\n  async checkUnseenEvents() {\n    if (!this.connected) {\n      this.shouldFetchUnseenEventsOnConnect = true;\n      return;\n    }\n    await new Promise(resolve => setTimeout(resolve, 250));\n    try {\n      await this.fetchUnseenEventsAPI();\n    } catch (e) {\n      console.error('Unable to check for unseen events', e);\n    }\n  }\n  async fetchUnseenEventsAPI() {\n    this.shouldFetchUnseenEventsOnConnect = false;\n    const responseEvents = await this.http.fetchUnseenEvents();\n    responseEvents.forEach(e => this.handleIncomingEvent(e));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns a Promise that completes when successful\n   */\n  async setSessionMetadata(key, value) {\n    const message = {\n      type: 'SetSessionConfig',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      metadata: {\n        [key]: value\n      }\n    };\n    return this.setOnceConnected(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to set session metadata');\n      }\n    });\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param unencryptedData unencrypted event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns a Promise that emits event ID when successful\n   */\n  async publishEvent(event, unencryptedData) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), {\n      origin: location.origin,\n      relaySource: 'coinbaseWalletExtension' in window && window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk'\n    })));\n    const message = {\n      type: 'PublishEvent',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      event,\n      data,\n      callWebhook\n    };\n    return this.setOnceLinked(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to publish event');\n      }\n      return res.eventId;\n    });\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData('h');\n    } catch (_a) {\n      // noop\n    }\n  }\n  async makeRequest(message) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n    const reqId = message.id;\n    this.sendData(message);\n    // await server message with corresponding id\n    let timeoutId;\n    return Promise.race([new Promise((_, reject) => {\n      timeoutId = window.setTimeout(() => {\n        reject(new Error(\"request \".concat(reqId, \" timed out\")));\n      }, timeout);\n    }), new Promise(resolve => {\n      this.requestResolutions.set(reqId, m => {\n        clearTimeout(timeoutId); // clear the timeout\n        resolve(m);\n        this.requestResolutions.delete(reqId);\n      });\n    })]);\n  }\n  async authenticate() {\n    const m = {\n      type: 'HostSession',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id,\n      sessionKey: this.session.key\n    };\n    const res = await this.makeRequest(m);\n    if (res.type === 'Fail') {\n      throw new Error(res.error || 'failed to authenticate');\n    }\n  }\n  sendIsLinked() {\n    const m = {\n      type: 'IsLinked',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id\n    };\n    this.sendData(m);\n  }\n  sendGetSessionConfig() {\n    const m = {\n      type: 'GetSessionConfig',\n      id: (0, type_1.IntNumber)(this.nextReqId++),\n      sessionId: this.session.id\n    };\n    this.sendData(m);\n  }\n}\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletLinkConnection","constants_1","require","WalletLinkCipher_1","WalletLinkHTTP_1","WalletLinkWebSocket_1","type_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","_ref","session","linkAPIUrl","listener","WebSocketClass","WebSocket","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","_connected","_linked","shouldFetchUnseenEventsOnConnect","requestResolutions","Map","handleSessionMetadataUpdated","metadata","handlers","handleDestroyed","handleAccountUpdated","handleWalletUsernameUpdated","handleAppVersionUpdated","v","JsonRpcUrl","handleChainUpdated","forEach","handler","key","undefined","__destroyed","_a","resetAndReload","encryptedEthereumAddress","address","cipher","decrypt","accountUpdated","handleMetadataUpdated","encryptedMetadataValue","decryptedValue","metadataUpdated","walletUsername","WALLET_USER_NAME_KEY","appVersion","APP_VERSION_KEY","encryptedChainId","encryptedJsonRpcUrl","chainId","jsonRpcUrl","chainUpdated","WalletLinkCipher","secret","ws","WalletLinkWebSocket","concat","setConnectionStateListener","state","connected","ConnectionState","DISCONNECTED","connect","Promise","resolve","setTimeout","catch","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","updateLastHeartbeat","setInterval","heartbeat","fetchUnseenEventsAPI","CONNECTING","setIncomingDataListener","m","type","linked","onlineGuests","handleIncomingEvent","id","get","http","WalletLinkHTTP","Error","destroy","disconnect","isDestroyed","onceConnected","call","setOnceConnected","callback","then","_b","onceLinked","linkedUpdated","setOnceLinked","event","decryptedData","data","message","JSON","parse","handleWeb3ResponseMessage","checkUnseenEvents","e","console","error","responseEvents","fetchUnseenEvents","setSessionMetadata","sessionId","res","makeRequest","publishEvent","unencryptedData","callWebhook","arguments","length","encrypt","stringify","assign","origin","location","relaySource","window","coinbaseWalletExtension","eventId","sendData","Date","now","timeout","reqId","timeoutId","race","_","reject","set","clearTimeout","delete","sessionKey"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletLinkConnection = void 0;\nconst constants_1 = require(\"../constants\");\nconst WalletLinkCipher_1 = require(\"./WalletLinkCipher\");\nconst WalletLinkHTTP_1 = require(\"./WalletLinkHTTP\");\nconst WalletLinkWebSocket_1 = require(\"./WalletLinkWebSocket\");\nconst type_1 = require(\"../../../../core/type\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletLinkConnection {\n    /**\n     * Constructor\n     * @param session Session\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param listener WalletLinkConnectionUpdateListener\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor({ session, linkAPIUrl, listener, WebSocketClass = WebSocket, }) {\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, type_1.IntNumber)(1);\n        /**\n         * true if connected and authenticated, else false\n         * runs listener when connected status changes\n         */\n        this._connected = false;\n        /**\n         * true if linked (a guest has joined before)\n         * runs listener when linked status changes\n         */\n        this._linked = false;\n        this.shouldFetchUnseenEventsOnConnect = false;\n        this.requestResolutions = new Map();\n        this.handleSessionMetadataUpdated = (metadata) => {\n            if (!metadata)\n                return;\n            // Map of metadata key to handler function\n            const handlers = new Map([\n                ['__destroyed', this.handleDestroyed],\n                ['EthereumAddress', this.handleAccountUpdated],\n                ['WalletUsername', this.handleWalletUsernameUpdated],\n                ['AppVersion', this.handleAppVersionUpdated],\n                [\n                    'ChainId',\n                    (v) => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl),\n                ],\n            ]);\n            // call handler for each metadata key if value is defined\n            handlers.forEach((handler, key) => {\n                const value = metadata[key];\n                if (value === undefined)\n                    return;\n                handler(value);\n            });\n        };\n        this.handleDestroyed = (__destroyed) => {\n            var _a;\n            if (__destroyed !== '1')\n                return;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n        };\n        this.handleAccountUpdated = async (encryptedEthereumAddress) => {\n            var _a;\n            {\n                const address = await this.cipher.decrypt(encryptedEthereumAddress);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n            }\n        };\n        this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n            var _a;\n            {\n                const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n            }\n        };\n        this.handleWalletUsernameUpdated = async (walletUsername) => {\n            this.handleMetadataUpdated(constants_1.WALLET_USER_NAME_KEY, walletUsername);\n        };\n        this.handleAppVersionUpdated = async (appVersion) => {\n            this.handleMetadataUpdated(constants_1.APP_VERSION_KEY, appVersion);\n        };\n        this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n            var _a;\n            {\n                const chainId = await this.cipher.decrypt(encryptedChainId);\n                const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n            }\n        };\n        this.session = session;\n        this.cipher = new WalletLinkCipher_1.WalletLinkCipher(session.secret);\n        this.listener = listener;\n        const ws = new WalletLinkWebSocket_1.WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocketClass);\n        ws.setConnectionStateListener(async (state) => {\n            // attempt to reconnect every 5 seconds when disconnected\n            let connected = false;\n            switch (state) {\n                case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:\n                    // if DISCONNECTED and not destroyed\n                    if (!this.destroyed) {\n                        const connect = async () => {\n                            // wait 5 seconds\n                            await new Promise((resolve) => setTimeout(resolve, 5000));\n                            // check whether it's destroyed again\n                            if (!this.destroyed) {\n                                // reconnect\n                                ws.connect().catch(() => {\n                                    connect();\n                                });\n                            }\n                        };\n                        connect();\n                    }\n                    break;\n                case WalletLinkWebSocket_1.ConnectionState.CONNECTED:\n                    // perform authentication upon connection\n                    try {\n                        // if CONNECTED, authenticate, and then check link status\n                        await this.authenticate();\n                        this.sendIsLinked();\n                        this.sendGetSessionConfig();\n                        connected = true;\n                    }\n                    catch (_a) {\n                        /* empty */\n                    }\n                    // send heartbeat every n seconds while connected\n                    // if CONNECTED, start the heartbeat timer\n                    // first timer event updates lastHeartbeat timestamp\n                    // subsequent calls send heartbeat message\n                    this.updateLastHeartbeat();\n                    setInterval(() => {\n                        this.heartbeat();\n                    }, HEARTBEAT_INTERVAL);\n                    // check for unseen events\n                    if (this.shouldFetchUnseenEventsOnConnect) {\n                        this.fetchUnseenEventsAPI();\n                    }\n                    break;\n                case WalletLinkWebSocket_1.ConnectionState.CONNECTING:\n                    break;\n            }\n            // distinctUntilChanged\n            if (this.connected !== connected) {\n                this.connected = connected;\n            }\n        });\n        ws.setIncomingDataListener((m) => {\n            var _a;\n            switch (m.type) {\n                // handle server's heartbeat responses\n                case 'Heartbeat':\n                    this.updateLastHeartbeat();\n                    return;\n                // handle link status updates\n                case 'IsLinkedOK':\n                case 'Linked': {\n                    const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n                    this.linked = linked || m.onlineGuests > 0;\n                    break;\n                }\n                // handle session config updates\n                case 'GetSessionConfigOK':\n                case 'SessionConfigUpdated': {\n                    this.handleSessionMetadataUpdated(m.metadata);\n                    break;\n                }\n                case 'Event': {\n                    this.handleIncomingEvent(m);\n                    break;\n                }\n            }\n            // resolve request promises\n            if (m.id !== undefined) {\n                (_a = this.requestResolutions.get(m.id)) === null || _a === void 0 ? void 0 : _a(m);\n            }\n        });\n        this.ws = ws;\n        this.http = new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        if (this.destroyed) {\n            throw new Error('instance is destroyed');\n        }\n        this.ws.connect();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        this.destroyed = true;\n        this.ws.disconnect();\n        this.listener = undefined;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    get connected() {\n        return this._connected;\n    }\n    set connected(connected) {\n        var _a;\n        this._connected = connected;\n        if (connected)\n            (_a = this.onceConnected) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    setOnceConnected(callback) {\n        return new Promise((resolve) => {\n            if (this.connected) {\n                callback().then(resolve);\n            }\n            else {\n                this.onceConnected = () => {\n                    callback().then(resolve);\n                    this.onceConnected = undefined;\n                };\n            }\n        });\n    }\n    get linked() {\n        return this._linked;\n    }\n    set linked(linked) {\n        var _a, _b;\n        this._linked = linked;\n        if (linked)\n            (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n    }\n    setOnceLinked(callback) {\n        return new Promise((resolve) => {\n            if (this.linked) {\n                callback().then(resolve);\n            }\n            else {\n                this.onceLinked = () => {\n                    callback().then(resolve);\n                    this.onceLinked = undefined;\n                };\n            }\n        });\n    }\n    async handleIncomingEvent(m) {\n        var _a;\n        if (m.type !== 'Event' || m.event !== 'Web3Response') {\n            return;\n        }\n        {\n            const decryptedData = await this.cipher.decrypt(m.data);\n            const message = JSON.parse(decryptedData);\n            if (message.type !== 'WEB3_RESPONSE')\n                return;\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message);\n        }\n    }\n    async checkUnseenEvents() {\n        if (!this.connected) {\n            this.shouldFetchUnseenEventsOnConnect = true;\n            return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 250));\n        try {\n            await this.fetchUnseenEventsAPI();\n        }\n        catch (e) {\n            console.error('Unable to check for unseen events', e);\n        }\n    }\n    async fetchUnseenEventsAPI() {\n        this.shouldFetchUnseenEventsOnConnect = false;\n        const responseEvents = await this.http.fetchUnseenEvents();\n        responseEvents.forEach((e) => this.handleIncomingEvent(e));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns a Promise that completes when successful\n     */\n    async setSessionMetadata(key, value) {\n        const message = {\n            type: 'SetSessionConfig',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            metadata: { [key]: value },\n        };\n        return this.setOnceConnected(async () => {\n            const res = await this.makeRequest(message);\n            if (res.type === 'Fail') {\n                throw new Error(res.error || 'failed to set session metadata');\n            }\n        });\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param unencryptedData unencrypted event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns a Promise that emits event ID when successful\n     */\n    async publishEvent(event, unencryptedData, callWebhook = false) {\n        const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, relaySource: 'coinbaseWalletExtension' in window && window.coinbaseWalletExtension\n                ? 'injected_sdk'\n                : 'sdk' })));\n        const message = {\n            type: 'PublishEvent',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            event,\n            data,\n            callWebhook,\n        };\n        return this.setOnceLinked(async () => {\n            const res = await this.makeRequest(message);\n            if (res.type === 'Fail') {\n                throw new Error(res.error || 'failed to publish event');\n            }\n            return res.eventId;\n        });\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData('h');\n        }\n        catch (_a) {\n            // noop\n        }\n    }\n    async makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        this.sendData(message);\n        // await server message with corresponding id\n        let timeoutId;\n        return Promise.race([\n            new Promise((_, reject) => {\n                timeoutId = window.setTimeout(() => {\n                    reject(new Error(`request ${reqId} timed out`));\n                }, timeout);\n            }),\n            new Promise((resolve) => {\n                this.requestResolutions.set(reqId, (m) => {\n                    clearTimeout(timeoutId); // clear the timeout\n                    resolve(m);\n                    this.requestResolutions.delete(reqId);\n                });\n            }),\n        ]);\n    }\n    async authenticate() {\n        const m = {\n            type: 'HostSession',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n            sessionKey: this.session.key,\n        };\n        const res = await this.makeRequest(m);\n        if (res.type === 'Fail') {\n            throw new Error(res.error || 'failed to authenticate');\n        }\n    }\n    sendIsLinked() {\n        const m = {\n            type: 'IsLinked',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n        };\n        this.sendData(m);\n    }\n    sendGetSessionConfig() {\n        const m = {\n            type: 'GetSessionConfig',\n            id: (0, type_1.IntNumber)(this.nextReqId++),\n            sessionId: this.session.id,\n        };\n        this.sendData(m);\n    }\n}\nexports.WalletLinkConnection = WalletLinkConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}