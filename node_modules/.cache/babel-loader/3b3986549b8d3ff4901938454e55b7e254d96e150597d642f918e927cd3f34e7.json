{"ast":null,"code":"const util = require('./util');\nconst abi = require('./abi');\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ? '0x0000000000000000000000000000000000000000000000000000000000000000' : util.keccak(this.encodeData(type, value, types, useV4))];\n        }\n        if (value === undefined) throw new Error(\"missing value for field \".concat(name, \" of type \").concat(type));\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)];\n        }\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n          return ['bytes32', util.keccak(value)];\n        }\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', util.keccak(abi.rawEncode(typeValuePairs.map(_ref => {\n            let [type] = _ref;\n            return type;\n          }), typeValuePairs.map(_ref2 => {\n            let [, value] = _ref2;\n            return value;\n          })))];\n        }\n        return [type, value];\n      };\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32');\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = util.keccak(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n    return abi.rawEncode(encodedTypes, encodedValues);\n  },\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n    for (const type of deps) {\n      const children = types[type];\n      if (!children) {\n        throw new Error('No type definition specified: ' + type);\n      }\n      result += type + '(' + types[type].map(_ref3 => {\n        let {\n          name,\n          type\n        } = _ref3;\n        return type + ' ' + name;\n      }).join(',') + ')';\n    }\n    return result;\n  },\n  /**\n   * Finds all types within a type definition object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies(primaryType, types) {\n    let results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    primaryType = primaryType.match(/^\\w*/)[0];\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n    results.push(primaryType);\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n    return results;\n  },\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashStruct(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return util.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType(primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types));\n  },\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n    return sanitizedData;\n  },\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash(typedData) {\n    let useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n    return util.keccak(Buffer.concat(parts));\n  }\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data);\n  },\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false);\n  },\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data);\n  }\n};\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) throw error;\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error;\n    return e.type + ' ' + e.name;\n  });\n  return abi.soliditySHA3(['bytes32', 'bytes32'], [abi.soliditySHA3(new Array(typedData.length).fill('string'), schema), abi.soliditySHA3(types, data)]);\n}","map":{"version":3,"names":["util","require","abi","TYPED_MESSAGE_SCHEMA","type","properties","types","additionalProperties","items","name","required","primaryType","domain","message","TypedDataUtils","encodeData","data","useV4","arguments","length","undefined","encodedTypes","encodedValues","hashType","encodeField","value","keccak","Error","concat","Buffer","from","lastIndexOf","parsedType","slice","typeValuePairs","map","item","rawEncode","_ref","_ref2","field","push","encodeType","result","deps","findTypeDependencies","filter","dep","sort","children","_ref3","join","results","match","includes","hashStruct","sanitizeData","sanitizedData","key","Object","assign","EIP712Domain","hash","typedData","parts","module","exports","hashForSignTypedDataLegacy","msgParams","typedSignatureHashLegacy","hashForSignTypedData_v3","hashForSignTypedData_v4","error","e","toBuffer","schema","soliditySHA3","Array","fill"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js"],"sourcesContent":["const util = require('./util')\nconst abi = require('./abi')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {type: 'string'},\n            type: {type: 'string'},\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: {type: 'string'},\n    domain: {type: 'object'},\n    message: {type: 'object'},\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if(useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            util.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if(value === undefined)\n          throw new Error(`missing value for field ${name} of type ${type}`)\n\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', util.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map(item =>\n            encodeField(name, parsedType, item))\n          return ['bytes32', util.keccak(abi.rawEncode(\n            typeValuePairs.map(([type]) => type),\n            typeValuePairs.map(([, value]) => value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = util.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = util.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return abi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error('No type definition specified: ' + type)\n      }\n      result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')'\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type definition object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    primaryType = primaryType.match(/^\\w*/)[0]\n    if (results.includes(primaryType) || types[primaryType] === undefined) { return results }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {Buffer} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return util.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types)\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return util.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data)\n  },\n\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false)\n  },\n\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data)\n  },\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) throw error\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) { return e.type })\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error\n    return e.type + ' ' + e.name\n  })\n\n  return abi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      abi.soliditySHA3(types, data)\n    ]\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}