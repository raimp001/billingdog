{"ast":null,"code":"// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\n/* eslint-disable */\n//prettier-ignore\nconst util = require('./util');\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n  return name;\n}\n\n// Parse N from type<N>\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n  return null;\n}\nfunction parseNumber(arg) {\n  var type = typeof arg;\n  if (type === 'string' || type === 'number') {\n    return BigInt(arg);\n  } else if (type === 'bigint') {\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n    size = parseTypeArray(type);\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);\n    }\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n    return util.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    const bitLength = util.bitLengthFromBigInt(num);\n    if (bitLength > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength);\n    }\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n    return util.bufferBEFromBigInt(num, 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    const bitLength = util.bitLengthFromBigInt(num);\n    if (bitLength > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength);\n    }\n    const twos = util.twosFromBigInt(num, 256);\n    return util.bufferBEFromBigInt(twos, 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n    return encodeSingle('uint256', num * BigInt(2) ** BigInt(size[1]));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg) * BigInt(2) ** BigInt(size[1]));\n  }\n  throw new Error('Unsupported or invalid type: ' + type);\n}\n\n// Is a type dynamic?\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n}\n\n// Is a type an array?\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode(types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 32 * types.length;\n  for (var i in types) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value);\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n  return Buffer.concat(output.concat(data));\n}\nfunction solidityPack(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n  var size, num;\n  var ret = [];\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    if (type === 'bytes') {\n      ret.push(value);\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'));\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'));\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20));\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type);\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size);\n      }\n      ret.push(util.setLengthRight(value, size));\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type);\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid uint<N> width: ' + size);\n      }\n      num = parseNumber(value);\n      const bitLength = util.bitLengthFromBigInt(num);\n      if (bitLength > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength);\n      }\n      ret.push(util.bufferBEFromBigInt(num, size / 8));\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type);\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid int<N> width: ' + size);\n      }\n      num = parseNumber(value);\n      const bitLength = util.bitLengthFromBigInt(num);\n      if (bitLength > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength);\n      }\n      const twos = util.twosFromBigInt(num, size);\n      ret.push(util.bufferBEFromBigInt(twos, size / 8));\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n  return Buffer.concat(ret);\n}\nfunction soliditySHA3(types, values) {\n  return util.keccak(solidityPack(types, values));\n}\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n};","map":{"version":3,"names":["util","require","elementaryName","name","startsWith","slice","parseTypeN","type","parseInt","exec","parseTypeNxM","tmp","parseTypeArray","match","parseNumber","arg","BigInt","Error","encodeSingle","size","num","ret","i","Buffer","isArray","length","lastIndexOf","JSON","parse","push","unshift","concat","zeros","setLengthRight","bitLength","bitLengthFromBigInt","bufferBEFromBigInt","twos","twosFromBigInt","isDynamic","rawEncode","types","values","output","data","headLength","value","cur","solidityPack","setLength","soliditySHA3","keccak","module","exports"],"sources":["/Users/shardingdog/billingdog/node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js"],"sourcesContent":["// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\n/* eslint-disable */\n//prettier-ignore\nconst util = require('./util')\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string' || type === 'number') {\n    return BigInt(arg)\n  } else if (type === 'bigint') {\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, util.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return util.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return util.bufferBEFromBigInt(num, 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    const bitLength = util.bitLengthFromBigInt(num)\n    if (bitLength > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n    }\n\n    const twos = util.twosFromBigInt(num, 256);\n\n    return util.bufferBEFromBigInt(twos, 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num * BigInt(2) ** BigInt(size[1]))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg) * BigInt(2) ** BigInt(size[1]))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 32 * types.length\n\n  for (var i in types) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nfunction solidityPack (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var size, num\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n\n    if (type === 'bytes') {\n      ret.push(value)\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'))\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'))\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20))\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type)\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size)\n      }\n\n      ret.push(util.setLengthRight(value, size))\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid uint<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      ret.push(util.bufferBEFromBigInt(num, size / 8))\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid int<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      const bitLength = util.bitLengthFromBigInt(num)\n      if (bitLength > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + bitLength)\n      }\n\n      const twos = util.twosFromBigInt(num, size);\n      ret.push(util.bufferBEFromBigInt(twos, size / 8))\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n\n  return Buffer.concat(ret)\n}\n\nfunction soliditySHA3 (types, values) {\n  return util.keccak(solidityPack(types, values))\n}\n\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}